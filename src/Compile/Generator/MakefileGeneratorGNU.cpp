/*
	Distributed under the OSI-approved BSD 3-Clause License.
	See accompanying file LICENSE.txt for details.
*/

#include "Compile/Generator/MakefileGeneratorGNU.hpp"

#include "State/AncillaryTools.hpp"
#include "Terminal/Commands.hpp"
#include "Terminal/Environment.hpp"
#include "Terminal/Output.hpp"
#include "Terminal/Unicode.hpp"
#include "Utility/List.hpp"
#include "Utility/String.hpp"

namespace chalet
{
/*****************************************************************************/
MakefileGeneratorGNU::MakefileGeneratorGNU(const BuildState& inState) :
	IStrategyGenerator(inState)
{
	// m_generateDependencies = inToolchain->type() != ToolchainType::MSVC && !Environment::isContinuousIntegrationServer();
	m_generateDependencies = true;
}

/*****************************************************************************/
void MakefileGeneratorGNU::addProjectRecipes(const ProjectTarget& inProject, const SourceOutputs& inOutputs, CompileToolchain& inToolchain, const std::string& inTargetHash)
{
	m_project = &inProject;
	m_toolchain = inToolchain.get();
	m_hash = inTargetHash;

	const auto& target = inOutputs.target;

	const std::string buildRecipes = getBuildRecipes(inOutputs);
	const auto printer = getPrinter();

	//
	//
	//
	//
	// ==============================================================================
	std::string makeTemplate = fmt::format(R"makefile(
{buildRecipes}
build_{hash}: {target}
	@{printer}
.PHONY: build_{hash}
)makefile",
		fmt::arg("hash", m_hash),
		FMT_ARG(printer),
		FMT_ARG(buildRecipes),
		FMT_ARG(target));

	m_targetRecipes.emplace_back(std::move(makeTemplate));

	m_toolchain = nullptr;
	m_project = nullptr;
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getContents(const std::string& inPath) const
{
	UNUSED(inPath);

	const auto& depDir = m_state.paths.depDir();
	const auto suffixes = String::getPrefixed(m_fileExtensions, ".");

#if defined(CHALET_WIN32)
	const auto shell = "cmd.exe";
#else
	const auto shell = "/bin/sh";
#endif

	auto recipes = String::join(m_targetRecipes);

	std::string makeTemplate = fmt::format(R"makefile(# Generated by Chalet

.SUFFIXES:
.SUFFIXES: {suffixes}

SHELL := {shell}{recipes}
.PRECIOUS: {depDir}/%.d
{depDir}/%.d: ;

-include $(DEPS_{hash})
)makefile",
		fmt::arg("hash", m_hash),
		FMT_ARG(suffixes),
		FMT_ARG(shell),
		FMT_ARG(recipes),
		FMT_ARG(depDir));

	return makeTemplate;
}

/*****************************************************************************/
void MakefileGeneratorGNU::reset()
{
	m_targetRecipes.clear();
	m_fileExtensions.clear();
	m_locationCache.clear();
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getBuildRecipes(const SourceOutputs& inOutputs)
{
	chalet_assert(m_project != nullptr, "");

	for (auto& ext : inOutputs.fileExtensions)
	{
		List::addIfDoesNotExist(m_fileExtensions, ext);
	}

	const auto& compilerConfig = m_state.toolchain.getConfig(m_project->language());
	const auto pchTarget = m_state.paths.getPrecompiledHeaderTarget(*m_project, compilerConfig.isClang());
	const auto& pch = m_project->pch();

	std::string recipes = getPchRecipe(pch, pchTarget);

	for (auto& ext : String::filterIf({ "rc", "RC" }, inOutputs.fileExtensions))
	{
		recipes += getRcRecipe(ext, pchTarget);
	}

	for (auto& ext : String::filterIf({ "cpp", "CPP", "cc", "CC", "cxx", "CXX", "c++", "C++", "c", "C" }, inOutputs.fileExtensions))
	{
		recipes += getCxxRecipe(ext, pchTarget);
	}

	for (auto& ext : String::filterIf({ "m", "M", "mm" }, inOutputs.fileExtensions))
	{
		recipes += getObjcRecipe(ext);
	}

	recipes += getTargetRecipe(inOutputs.target);

	return recipes;
}

/*****************************************************************************/
/*std::string MakefileGeneratorGNU::getObjBuildRecipes(const StringList& inObjects, const std::string& pchTarget)
{
	const auto objDir = fmt::format("{}/", m_state.paths.objDir());

	std::string ret;

	for (auto& obj : inObjects)
	{
		if (obj.empty())
			continue;

		std::string source = obj;
		String::replaceAll(source, objDir, "");

		if (String::endsWith(".o", source))
			source = source.substr(0, source.size() - 2);
		else if (String::endsWith(".res", source))
			source = source.substr(0, source.size() - 4);

		if (String::endsWith({ ".rc", ".RC" }, source))
		{
			ret += getRcRecipe(source, obj);
		}
		else if (String::endsWith({ ".m", ".M", ".mm" }, source))
		{
			ret += getObjcRecipe(source, obj);
		}
		else
		{
			ret += getCppRecipe(source, obj, pchTarget);
		}
	}

	return ret;
}*/

/*****************************************************************************/
std::string MakefileGeneratorGNU::getCompileEchoSources(const std::string& inFile) const
{
	const auto color = getBuildColor();
	std::string printer;

	if (Output::cleanOutput())
	{
		printer = getPrinter(fmt::format("   {}{}", color, inFile), true);
	}
	else
	{
		printer = getPrinter(std::string(color));
	}

	return fmt::format("@{}", printer);
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getLinkerEcho() const
{
	const auto color = getBuildColor();
	std::string printer;

	if (Output::cleanOutput())
	{
		const std::string description = m_project->isStaticLibrary() ? "Archiving" : "Linking";
		const auto text = fmt::format("{color}   {description} $@", FMT_ARG(color), FMT_ARG(description));
		printer = getPrinter(text, true);
	}
	else
	{
		printer = getPrinter(std::string(color));
	}

	return fmt::format("@{}", printer);
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getPchRecipe(const std::string& source, const std::string& object)
{
	chalet_assert(m_project != nullptr, "");
	chalet_assert(m_toolchain != nullptr, "");

	std::string ret;

	const bool usePch = m_project->usesPch();

	if (usePch && !List::contains(m_precompiledHeaders, source))
	{
		// auto pchAbsolute = Commands::getAbsolutePath(source);
		const auto quietFlag = getQuietFlag();
		const auto& depDir = m_state.paths.depDir();
		m_precompiledHeaders.push_back(source);

		const auto dependency = fmt::format("{}/{}.d", depDir, source);

#if defined(CHALET_MACOS)
		if (m_state.info.targetArchitecture() == Arch::Cpu::UniversalMacOS)
		{
			auto baseFolder = String::getPathFolder(object);
			auto filename = String::getPathFilename(object);

			std::string lastArch;
			for (auto& arch : m_state.info.universalArches())
			{
				auto outObject = fmt::format("{}_{}/{}", baseFolder, arch, filename);
				auto dependencies = source;

				if (!lastArch.empty())
				{
					dependencies += fmt::format(" {}_{}/{}", baseFolder, lastArch, filename);
				}

				auto pchCompile = String::join(m_toolchain->getPchCompileCommand("$<", "$@", m_generateDependencies, dependency, arch));
				if (!pchCompile.empty())
				{
					const auto compileEcho = getCompileEchoSources(String::getPathFolderBaseName(outObject));
					ret += fmt::format(R"makefile(
{outObject}: {dependencies} | {dependency}
	{compileEcho}
	{quietFlag}{pchCompile}
)makefile",
						FMT_ARG(outObject),
						FMT_ARG(dependencies),
						FMT_ARG(compileEcho),
						FMT_ARG(quietFlag),
						FMT_ARG(pchCompile),
						FMT_ARG(dependency));
				}
				lastArch = arch;
			}
		}
		else
#endif
		{
			auto pchCompile = String::join(m_toolchain->getPchCompileCommand("$<", "$@", m_generateDependencies, dependency, std::string()));
			if (!pchCompile.empty())
			{
				const auto compileEcho = getCompileEchoSources(String::getPathFolderBaseName(object));
				ret += fmt::format(R"makefile(
{object}: {source} | {dependency}
	{compileEcho}
	{quietFlag}{pchCompile}
)makefile",
					FMT_ARG(object),
					FMT_ARG(source),
					FMT_ARG(compileEcho),
					FMT_ARG(quietFlag),
					FMT_ARG(pchCompile),
					FMT_ARG(dependency));
			}
		}
	}

	return ret;
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getRcRecipe(const std::string& ext, const std::string& pchTarget) const
{
	chalet_assert(m_project != nullptr, "");
	chalet_assert(m_toolchain != nullptr, "");

	std::string ret;

	const auto quietFlag = getQuietFlag();
	const auto& depDir = m_state.paths.depDir();
	const auto& objDir = m_state.paths.objDir();
	const auto compileEcho = getCompileEchoSources();

	for (auto& location : m_project->locations())
	{
		if (locationExists(location, ext))
			continue;

		const auto dependency = fmt::format("{}/{}/$*.{}.d", depDir, location, ext);

		auto rcCompile = String::join(m_toolchain->getRcCompileCommand("$<", "$@", m_generateDependencies, dependency));
		if (!rcCompile.empty())
		{
			std::string makeDependency;
			if (m_generateDependencies && m_state.toolchain.usingLlvmRC())
			{
				makeDependency = fmt::format("\n\t@{}", getFallbackMakeDependsCommand(dependency, "$<", "$@"));
			}

			ret += fmt::format(R"makefile(
{objDir}/{location}/%.{ext}.res: {location}/%.{ext} {pchTarget} | {depDir}/{location}/%.{ext}.d
	{compileEcho}
	{quietFlag}{rcCompile}{makeDependency}
)makefile",
				FMT_ARG(objDir),
				FMT_ARG(depDir),
				FMT_ARG(ext),
				FMT_ARG(location),
				FMT_ARG(pchTarget),
				FMT_ARG(dependency),
				FMT_ARG(compileEcho),
				FMT_ARG(quietFlag),
				FMT_ARG(rcCompile),
				FMT_ARG(makeDependency));

			m_locationCache[location].push_back(ext);
		}
	}

	return ret;
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getCxxRecipe(const std::string& ext, const std::string& pchTarget) const
{
	chalet_assert(m_project != nullptr, "");
	chalet_assert(m_toolchain != nullptr, "");

	std::string ret;

	const auto quietFlag = getQuietFlag();
	const auto& depDir = m_state.paths.depDir();
	const auto& objDir = m_state.paths.objDir();
	const bool usePch = m_project->usesPch();
	const auto compileEcho = getCompileEchoSources();
	const auto specialization = m_project->language() == CodeLanguage::CPlusPlus ? CxxSpecialization::CPlusPlus : CxxSpecialization::C;

	for (auto& location : m_project->locations())
	{
		if (locationExists(location, ext))
			continue;

		const auto dependency = fmt::format("{}/{}/$*.{}.d", depDir, location, ext);

		auto cppCompile = String::join(m_toolchain->getCxxCompileCommand("$<", "$@", m_generateDependencies, dependency, specialization));
		if (!cppCompile.empty())
		{
			std::string pch = pchTarget;

#if defined(CHALET_MACOS)
			if (m_state.info.targetArchitecture() == Arch::Cpu::UniversalMacOS && usePch)
			{
				auto baseFolder = String::getPathFolder(pchTarget);
				auto filename = String::getPathFilename(pchTarget);
				auto& lastArch = m_state.info.universalArches().back();
				pch = fmt::format("{}_{}/{}", baseFolder, lastArch, filename);
			}
			else
#endif
			{
				pch = pchTarget;
			}

			ret += fmt::format(R"makefile(
{objDir}/{location}/%.{ext}.o: {location}/%.{ext} {pch} | {depDir}/{location}/%.{ext}.d
	{compileEcho}
	{quietFlag}{cppCompile}
)makefile",
				FMT_ARG(objDir),
				FMT_ARG(depDir),
				FMT_ARG(ext),
				FMT_ARG(location),
				FMT_ARG(pch),
				FMT_ARG(dependency),
				FMT_ARG(compileEcho),
				FMT_ARG(quietFlag),
				FMT_ARG(cppCompile));

			m_locationCache[location].push_back(ext);
		}
	}

	return ret;
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getObjcRecipe(const std::string& ext) const
{
	chalet_assert(m_project != nullptr, "");
	chalet_assert(m_toolchain != nullptr, "");

	std::string ret;

	const bool objectiveC = String::equals({ "m", "M" }, ext); // mm & M imply C++

	const auto quietFlag = getQuietFlag();
	const auto& depDir = m_state.paths.depDir();
	const auto& objDir = m_state.paths.objDir();
	const auto compileEcho = getCompileEchoSources();

	for (auto& location : m_project->locations())
	{
		if (locationExists(location, ext))
			continue;

		const auto dependency = fmt::format("{}/{}/$*.{}.d", depDir, location, ext);

		const auto specialization = objectiveC ? CxxSpecialization::ObjectiveC : CxxSpecialization::ObjectiveCPlusPlus;
		auto objcCompile = String::join(m_toolchain->getCxxCompileCommand("$<", "$@", m_generateDependencies, dependency, specialization));
		if (!objcCompile.empty())
		{

			ret += fmt::format(R"makefile(
{objDir}/{location}/%.{ext}.o: {location}/%.{ext} | {depDir}/{location}/%.{ext}.d
	{compileEcho}
	{quietFlag}{objcCompile}
)makefile",
				FMT_ARG(objDir),
				FMT_ARG(depDir),
				FMT_ARG(ext),
				FMT_ARG(location),
				FMT_ARG(dependency),
				FMT_ARG(compileEcho),
				FMT_ARG(quietFlag),
				FMT_ARG(objcCompile));

			m_locationCache[location].push_back(ext);
		}
	}

	return ret;
}

/*****************************************************************************/
bool MakefileGeneratorGNU::locationExists(const std::string& location, const std::string& ext) const
{
	bool found = false;
	for (auto& e : m_locationCache[location])
	{
		if (e == ext)
		{
			found = true;
			break;
		}
	}

	return found;
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getTargetRecipe(const std::string& linkerTarget) const
{
	chalet_assert(m_project != nullptr, "");
	chalet_assert(m_toolchain != nullptr, "");

	std::string ret;

	const auto quietFlag = getQuietFlag();

	const auto preReqs = getLinkerPreReqs();

	const auto linkerTargetBase = m_state.paths.getTargetBasename(*m_project);
	const auto linkerCommand = String::join(m_toolchain->getLinkerTargetCommand(linkerTarget, { fmt::format("$(OBJS_{})", m_hash) }, linkerTargetBase));
	if (!linkerCommand.empty())
	{
		const auto linkerEcho = getLinkerEcho();
		const auto printer = getPrinter("\\n");

		ret = fmt::format(R"makefile(
{linkerTarget}: {preReqs}
	{linkerEcho}
	{quietFlag}{linkerCommand}
	@{printer}
)makefile",
			FMT_ARG(linkerTarget),
			FMT_ARG(preReqs),
			FMT_ARG(linkerEcho),
			FMT_ARG(quietFlag),
			FMT_ARG(linkerCommand),
			FMT_ARG(printer));
	}

	return ret;
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getLinkerPreReqs() const
{
	chalet_assert(m_project != nullptr, "");

	std::string ret = fmt::format("$(OBJS_{})", m_hash);

	uint count = 0;
	for (auto& target : m_state.targets)
	{
		if (target->isProject())
		{
			auto& project = static_cast<const ProjectTarget&>(*target);
			/*if (List::contains(m_project->links(), project.name()))
			{
				if (count == 0)
					ret += " |";
				ret += " " + m_state.paths.getTargetFilename(project);
				++count;
			}
			else
			*/
			if (List::contains(m_project->projectStaticLinks(), project.name()))
			{
				if (count == 0)
					ret += " |";
				ret += " " + m_state.paths.getTargetFilename(project);
				++count;
			}
		}
	}

	return ret;
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getQuietFlag() const
{
	return Output::cleanOutput() ? "@" : "";
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getFallbackMakeDependsCommand(const std::string& inDependencyFile, const std::string& object, const std::string& source) const
{
	std::string contents = fmt::format("{}: \\\\\\n  {}\\n", object, source);
	return fmt::format("echo \"{contents}\" > \"{inDependencyFile}\"",
		FMT_ARG(contents),
		FMT_ARG(inDependencyFile));
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getPrinter(const std::string& inPrint, const bool inNewLine) const
{
	if (!Environment::isBash() && inPrint == "\\n")
	{
		return "echo.";
	}

	if (inPrint.empty())
	{
		return Environment::isBash() ? ":" : "rem"; // This just needs to be a noop
	}

	if (Environment::isBash())
	{
		return fmt::format("printf '{}{}'", inPrint, inNewLine ? "\\n" : "");
	}
	else
	{
		if (inNewLine)
			return fmt::format("echo {}", inPrint);
		else
			return fmt::format("echo|set /p CMD_NOLINE=\"{}\"", inPrint);
	}
}

/*****************************************************************************/
std::string MakefileGeneratorGNU::getBuildColor() const
{
	auto color = Output::getAnsiStyleUnescaped(Output::theme().build);
#if defined(CHALET_WIN32)
	return fmt::format("\x1b[{}m", color);
#else
	return fmt::format("\\033[{}m", color);
#endif
}
}
