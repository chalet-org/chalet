/*
	Distributed under the OSI-approved BSD 3-Clause License.
	See accompanying file LICENSE.txt for details.
*/

#include "Compile/CompilerCxx/CompilerCxxGCC.hpp"

#include "BuildEnvironment/IBuildEnvironment.hpp"
#include "Cache/WorkspaceCache.hpp"
#include "Compile/CompilerCxx/CompilerCxxAppleClang.hpp"
#include "Core/CommandLineInputs.hpp"
#include "State/AncillaryTools.hpp"
#include "State/BuildConfiguration.hpp"
#include "State/BuildInfo.hpp"
#include "State/BuildPaths.hpp"
#include "State/BuildState.hpp"
#include "State/CompilerTools.hpp"
#include "State/Target/SourceTarget.hpp"
#include "System/Files.hpp"
#include "Utility/List.hpp"
#include "Utility/RegexPatterns.hpp"
#include "Utility/String.hpp"

namespace chalet
{
/*****************************************************************************/
CompilerCxxGCC::CompilerCxxGCC(const BuildState& inState, const SourceTarget& inProject) :
	ICompilerCxx(inState, inProject)
{
}

/*****************************************************************************/
bool CompilerCxxGCC::initialize()
{
	if (!configureWarnings())
		return false;

	if (m_project.usesPrecompiledHeader())
	{
		auto makeIntermediateHeader = [this](const std::string outPath, const std::string& pch) -> bool {
			if (!Files::pathExists(outPath))
			{
				auto pragmaId = getPragmaId();
				auto pchAbsolute = Files::getAbsolutePath(pch);
				auto contents = fmt::format(R"cpp(// Generated by Chalet

#pragma {pragmaId} system_header
#ifdef __cplusplus
	#include "{pchAbsolute}"
#endif)cpp",
					FMT_ARG(pragmaId),
					FMT_ARG(pchAbsolute));

				if (!Files::createFileWithContents(outPath, contents))
					return false;
			}

			return true;
		};

		const auto& pch = m_project.precompiledHeader();
		auto pchIntermediate = m_state.environment->getPrecompiledHeaderIntermediateFile(pch);

#if defined(CHALET_MACOS)
		if (m_state.info.targetArchitecture() == Arch::Cpu::UniversalMacOS)
		{
			auto baseFolder = String::getPathFolder(pchIntermediate);
			auto filename = String::getPathFilename(pchIntermediate);

			for (auto& arch : m_state.inputs.universalArches())
			{
				auto outFile = fmt::format("{}_{}/{}", baseFolder, arch, filename);

				if (!makeIntermediateHeader(outFile, pch))
					return false;
			}
		}
		else
#endif
		{
			// make the intermediate header for the PCH
			if (!makeIntermediateHeader(pchIntermediate, pch))
				return false;
		}
	}

	return true;
}

/*****************************************************************************/
bool CompilerCxxGCC::configureWarnings()
{
	m_warnings.clear();

	bool result = true;
	auto warningsPreset = m_project.warningsPreset();
	if (warningsPreset == ProjectWarningPresets::None)
		return result;

	m_warnings.emplace_back("all");

	if (warningsPreset == ProjectWarningPresets::Minimal)
		return result;

	m_warnings.emplace_back("extra");

	if (warningsPreset == ProjectWarningPresets::Extra)
		return result;

	m_warnings.emplace_back("pedantic");
	// m_warnings.emplace_back("pedantic-errors");

	if (warningsPreset == ProjectWarningPresets::Pedantic)
		return result;

	m_warnings.emplace_back("unused");
	m_warnings.emplace_back("cast-align");
	m_warnings.emplace_back("double-promotion");
	m_warnings.emplace_back("format=2");
	m_warnings.emplace_back("missing-declarations");
	m_warnings.emplace_back("missing-include-dirs");
	m_warnings.emplace_back("non-virtual-dtor");
	m_warnings.emplace_back("redundant-decls");

	if (warningsPreset == ProjectWarningPresets::Strict)
		return result;

	m_warnings.emplace_back("unreachable-code"); // clang only
	m_warnings.emplace_back("shadow");

	if (warningsPreset == ProjectWarningPresets::StrictPedantic)
		return result;

	m_warnings.emplace_back("noexcept");
	m_warnings.emplace_back("undef");
	m_warnings.emplace_back("conversion");
	m_warnings.emplace_back("cast-qual");
	m_warnings.emplace_back("float-equal");
	m_warnings.emplace_back("inline");
	m_warnings.emplace_back("old-style-cast");
	m_warnings.emplace_back("strict-null-sentinel");
	m_warnings.emplace_back("overloaded-virtual");
	m_warnings.emplace_back("sign-conversion");
	m_warnings.emplace_back("sign-promo");

	// if (warningsPreset == ProjectWarningPresets::VeryStrict)
	// 	return result;

	return result;
}

/*****************************************************************************/
std::string CompilerCxxGCC::getPragmaId() const
{
	return std::string("GCC");
}

/*****************************************************************************/
StringList CompilerCxxGCC::getWarningExclusions() const
{
	return {};
}

/*****************************************************************************/
bool CompilerCxxGCC::isFlagSupported(const std::string& inFlag) const
{
	if (String::contains('=', inFlag))
	{
		auto cutoff = inFlag.find('=');
		// std::string flag = inFlag.substr(cutoff + 1);
		std::string flag = inFlag.substr(0, cutoff);
		return m_state.environment->isCompilerFlagSupported(String::toLowerCase(flag));
	}
	else
	{
		return m_state.environment->isCompilerFlagSupported(String::toLowerCase(inFlag));
	}
}

/*****************************************************************************/
StringList CompilerCxxGCC::getPrecompiledHeaderCommand(const std::string& inputFile, const std::string& outputFile, const std::string& dependency, const std::string& arch)
{
	StringList ret;

	if (!addExecutable(ret))
		return ret;

	if (generateDependencies())
	{
		ret.emplace_back("-MT");
		ret.emplace_back(getQuotedPath(outputFile));
		ret.emplace_back("-MMD");
		ret.emplace_back("-MP");
		ret.emplace_back("-MF");
		ret.emplace_back(getQuotedPath(dependency));
	}

	auto derivative = SourceType::CxxPrecompiledHeader;

	addSourceFileInterpretation(ret, derivative);
	addOptimizations(ret);
	addLanguageStandard(ret, derivative);
	addCppCoroutines(ret);
	addCppConcepts(ret);
	addWarnings(ret);

	addCharsets(ret);
	addLibStdCppCompileOption(ret, derivative);
	addPositionIndependentCodeOption(ret);
	addCompileOptions(ret);
	addObjectiveCxxRuntimeOption(ret, derivative);
	addDiagnosticColorOption(ret);
	addFastMathOption(ret);
	addNoRunTimeTypeInformationOption(ret);
	addNoExceptionsOption(ret);
	addThreadModelCompileOption(ret);
	addArchitecture(ret, arch);
	addSystemRootOption(ret);
	addLinkTimeOptimizations(ret);

	addDebuggingInformationOption(ret);
	addProfileInformation(ret);
	addSanitizerOptions(ret);

	addDefines(ret);
	addIncludes(ret);
	addSystemIncludes(ret);

	ret.emplace_back("-o");
	ret.emplace_back(getQuotedPath(outputFile));
	ret.emplace_back("-c");
	ret.emplace_back(getQuotedPath(inputFile));

	return ret;
}

/*****************************************************************************/
StringList CompilerCxxGCC::getCommand(const std::string& inputFile, const std::string& outputFile, const std::string& dependency, const SourceType derivative)
{
	StringList ret;

	if (!addExecutable(ret))
		return ret;

	if (generateDependencies())
	{
		ret.emplace_back("-MT");
		ret.emplace_back(getQuotedPath(outputFile));
		ret.emplace_back("-MMD");
		ret.emplace_back("-MP");
		ret.emplace_back("-MF");
		ret.emplace_back(getQuotedPath(dependency));
	}

	addSourceFileInterpretation(ret, derivative);
	addOptimizations(ret);
	addLanguageStandard(ret, derivative);
	addCppCoroutines(ret);
	addCppConcepts(ret);
	addWarnings(ret);

	addCharsets(ret);
	addLibStdCppCompileOption(ret, derivative);
	addPositionIndependentCodeOption(ret);
	addCompileOptions(ret);
	addObjectiveCxxRuntimeOption(ret, derivative);
	addDiagnosticColorOption(ret);
	addFastMathOption(ret);
	addNoRunTimeTypeInformationOption(ret);
	addNoExceptionsOption(ret);
	addThreadModelCompileOption(ret);
	addArchitecture(ret, std::string());
	addSystemRootOption(ret);
	addLinkTimeOptimizations(ret);

	addDebuggingInformationOption(ret);
	addProfileInformation(ret);
	addSanitizerOptions(ret);

	addDefines(ret);

	// Before other includes
	addPchInclude(ret, derivative);

	addIncludes(ret);
	addSystemIncludes(ret);

	ret.emplace_back("-o");
	ret.emplace_back(getQuotedPath(outputFile));
	ret.emplace_back("-c");
	ret.emplace_back(getQuotedPath(inputFile));

	return ret;
}

/*****************************************************************************/
void CompilerCxxGCC::getCommandOptions(StringList& outArgList, const SourceType derivative)
{
	addSourceFileInterpretation(outArgList, derivative);
	addOptimizations(outArgList);
	addLanguageStandard(outArgList, derivative);
	addCppCoroutines(outArgList);
	addCppConcepts(outArgList);
	addWarnings(outArgList);

	addCharsets(outArgList);
	addLibStdCppCompileOption(outArgList, derivative);
	addPositionIndependentCodeOption(outArgList);
	addCompileOptions(outArgList);
	addObjectiveCxxRuntimeOption(outArgList, derivative);
	addDiagnosticColorOption(outArgList);
	addFastMathOption(outArgList);
	addNoRunTimeTypeInformationOption(outArgList);
	addNoExceptionsOption(outArgList);
	addThreadModelCompileOption(outArgList);
	addArchitecture(outArgList, std::string());
	addSystemRootOption(outArgList);
	addLinkTimeOptimizations(outArgList);

	addDebuggingInformationOption(outArgList);
	addProfileInformation(outArgList);
	addSanitizerOptions(outArgList);

	addDefines(outArgList);

	// Before other includes
	// addPchInclude(outArgList, derivative);
}

/*****************************************************************************/
StringList CompilerCxxGCC::getModuleCommand(const std::string& inputFile, const std::string& outputFile, const std::string& dependency, const std::string& interfaceFile, const StringList& inModuleReferences, const StringList& inHeaderUnits, const ModuleFileType inType)
{
	UNUSED(inModuleReferences, inHeaderUnits);

	StringList ret;

	if (!addExecutable(ret))
		return ret;

	if (generateDependencies())
	{
		ret.emplace_back("-MT");
		ret.emplace_back(getQuotedPath(interfaceFile));
		ret.emplace_back("-MMD");
		ret.emplace_back("-MP");
		ret.emplace_back("-MF");
		ret.emplace_back(getQuotedPath(dependency));
	}

	constexpr auto derivative = SourceType::CPlusPlus;

	addSourceFileInterpretation(ret, inType);

	ret.emplace_back("-fmodules-ts");

	ret.emplace_back(fmt::format("-fmodule-mapper={}", m_state.environment->getModuleDirectivesDependencyFile(inputFile)));
	// ret.emplace_back(fmt::format("-fmodule-mapper=|@g++-mapper-server -r{}/.mmap", m_state.paths.objDir()));

	// if (inType == ModuleFileType::HeaderUnitObject)
	// {
	// 	ret.emplace_back("-flang-info-include-translate");
	// 	ret.emplace_back("-flang-info-module-cmi");
	// }

	if (inType == ModuleFileType::ModuleDependency)
	{
		// ret.emplace_back(fmt::format("-fdep-file={}", getQuotedPath(interfaceFile)));
		// ret.emplace_back(fmt::format("-fdep-output={}", getQuotedPath(outputFile)));
	}

	addOptimizations(ret);
	addLanguageStandard(ret, derivative);
	addCppCoroutines(ret);
	addCppConcepts(ret);
	addWarnings(ret);

	addCharsets(ret);
	addLibStdCppCompileOption(ret, derivative);
	addPositionIndependentCodeOption(ret);
	addCompileOptions(ret);
	addObjectiveCxxRuntimeOption(ret, derivative);
	addDiagnosticColorOption(ret);
	addFastMathOption(ret);
	addNoRunTimeTypeInformationOption(ret);
	addNoExceptionsOption(ret);
	addThreadModelCompileOption(ret);
	addArchitecture(ret, std::string());
	addSystemRootOption(ret);
	addLinkTimeOptimizations(ret);

	addDebuggingInformationOption(ret);
	addProfileInformation(ret);
	addSanitizerOptions(ret);

	addDefines(ret);

	// Before other includes
	addPchInclude(ret, derivative);

	addIncludes(ret);
	addSystemIncludes(ret);

	ret.emplace_back("-o");
	ret.emplace_back(getQuotedPath(outputFile));
	ret.emplace_back("-c");
	if (inType == ModuleFileType::SystemHeaderUnitObject)
		ret.emplace_back(getQuotedPath(String::getPathFilename(inputFile)));
	else
		ret.emplace_back(getQuotedPath(inputFile));

	return ret;
}

/*****************************************************************************/
void CompilerCxxGCC::addSourceFileInterpretation(StringList& outArgList, const SourceType derivative) const
{
	outArgList.emplace_back("-x");

	auto language = m_project.language();
	if (m_project.objectiveCxx())
	{
		if (derivative == SourceType::CxxPrecompiledHeader && language == CodeLanguage::ObjectiveCPlusPlus)
			outArgList.emplace_back("objective-c++-header");
		else if (derivative == SourceType::CxxPrecompiledHeader && language == CodeLanguage::ObjectiveC)
			outArgList.emplace_back("objective-c-header");
		else if (derivative == SourceType::ObjectiveCPlusPlus || derivative == SourceType::CPlusPlus)
			outArgList.emplace_back("objective-c++");
		else
			outArgList.emplace_back("objective-c");
	}
	else
	{
		if (derivative == SourceType::CxxPrecompiledHeader && language == CodeLanguage::CPlusPlus)
			outArgList.emplace_back("c++-header");
		else if (derivative == SourceType::CxxPrecompiledHeader && language == CodeLanguage::C)
			outArgList.emplace_back("c-header");
		else if (derivative == SourceType::ObjectiveCPlusPlus || derivative == SourceType::CPlusPlus)
			outArgList.emplace_back("c++");
		else
			outArgList.emplace_back("c");
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addSourceFileInterpretation(StringList& outArgList, const ModuleFileType moduleType) const
{
	outArgList.emplace_back("-x");

	if (moduleType == ModuleFileType::SystemHeaderUnitObject)
		outArgList.emplace_back("c++-system-header");
	else if (moduleType == ModuleFileType::HeaderUnitObject)
		outArgList.emplace_back("c++-header");
	else
		outArgList.emplace_back("c++");
}

/*****************************************************************************/
void CompilerCxxGCC::addIncludes(StringList& outArgList) const
{
	const std::string prefix{ "-I" };
	for (const auto& dir : m_project.includeDirs())
	{
		std::string outDir = dir;
		if (String::endsWith('/', outDir))
			outDir.pop_back();

		outArgList.emplace_back(getPathCommand(prefix, outDir));
	}

	if (m_project.usesPrecompiledHeader())
	{
		auto outDir = String::getPathFolder(m_project.precompiledHeader());
		List::addIfDoesNotExist(outArgList, getPathCommand(prefix, outDir));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addWarnings(StringList& outArgList) const
{
	auto excludes = getWarningExclusions();

	const std::string prefix{ "-W" };
	for (auto& warning : m_warnings)
	{
		if (List::contains(excludes, warning))
			continue;

		std::string out;
		if (String::equals(warning, "pedantic-errors"))
			out = "-" + warning;
		else
			out = prefix + warning;

		// if (isFlagSupported(out))
		List::addIfDoesNotExist(outArgList, std::move(out));
	}

	for (auto& warning : m_project.warnings())
	{
		if (List::contains(excludes, warning))
			continue;

		std::string out;
		if (String::equals(warning, "pedantic-errors"))
			out = "-" + warning;
		else
			out = prefix + warning;

		// if (isFlagSupported(out))
		List::addIfDoesNotExist(outArgList, std::move(out));
	}

	if (m_project.usesPrecompiledHeader())
	{
		std::string warning = "invalid-pch";

		if (!List::contains(excludes, warning))
		{
			std::string option = prefix + warning;
			// if (isFlagSupported(option))
			List::addIfDoesNotExist(outArgList, std::move(option));
		}
	}

	if (m_project.treatWarningsAsErrors())
	{
		std::string option = prefix + "error";
		// if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addDefines(StringList& outArgList) const
{
	addDefinesToList(outArgList, "-D");
}

/*****************************************************************************/
void CompilerCxxGCC::addPchInclude(StringList& outArgList, const SourceType derivative) const
{
	if (precompiledHeaderAllowedForSourceType(derivative))
	{
		outArgList.emplace_back("-include");

		if (m_forceActualPchPath)
		{
			outArgList.emplace_back(getPathCommand("", m_project.precompiledHeader()));
		}
		else
		{
			const auto objDirPch = m_state.paths.getPrecompiledHeaderInclude(m_project);
			outArgList.emplace_back(getPathCommand("", objDirPch));
		}
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addOptimizations(StringList& outArgList) const
{
	std::string opt;

	OptimizationLevel level = m_state.configuration.optimizationLevel();

	if (m_state.configuration.debugSymbols()
		&& level != OptimizationLevel::Debug
		&& level != OptimizationLevel::None
		&& level != OptimizationLevel::CompilerDefault)
	{
		// force -O0 (anything else would be in error)
		opt = "-O0";
	}
	else
	{
		switch (level)
		{
			case OptimizationLevel::L1:
				opt = "-O1";
				break;

			case OptimizationLevel::L2:
				opt = "-O2";
				break;

			case OptimizationLevel::L3:
				opt = "-O3";
				break;

			case OptimizationLevel::Debug:
				opt = "-Og";
				break;

			case OptimizationLevel::Size:
				opt = "-Os";
				break;

			case OptimizationLevel::Fast:
				opt = "-Ofast";
				break;

			case OptimizationLevel::None:
				opt = "-O0";
				break;

			case OptimizationLevel::CompilerDefault:
			default:
				break;
		}
	}

	if (opt.empty())
		return;

	outArgList.emplace_back(std::move(opt));
}

/*****************************************************************************/
void CompilerCxxGCC::addLanguageStandard(StringList& outArgList, const SourceType derivative) const
{
	const CodeLanguage language = m_project.language();
	bool validPchType = derivative == SourceType::CxxPrecompiledHeader && (language == CodeLanguage::C || language == CodeLanguage::ObjectiveC);
	bool useC = validPchType || derivative == SourceType::C || derivative == SourceType::ObjectiveC;

	const auto& langStandard = useC ? m_project.cStandard() : m_project.cppStandard();
	std::string ret = String::toLowerCase(langStandard);

	bool isGcc = m_state.environment->isGcc();
	if (!useC)
	{
		if (RegexPatterns::matchesGnuCppStandard(ret))
		{
			std::string yearOnly = ret;
			String::replaceAll(yearOnly, "gnu++", "");
			String::replaceAll(yearOnly, "c++", "");

			if (String::equals("26", yearOnly) && (isGcc /* && m_versionMajorMinor < 1300 */))
			{
				String::replaceAll(ret, "26", "2c");
			}
			else if (String::equals("23", yearOnly) && (isGcc && m_versionMajorMinor < 1300))
			{
				String::replaceAll(ret, "23", "2b");
			}
			else if (String::equals("20", yearOnly) && (isGcc && m_versionMajorMinor < 1000))
			{
				String::replaceAll(ret, "20", "2a");
			}
			else if (String::equals("17", yearOnly) && (isGcc && m_versionMajorMinor < 703))
			{
				String::replaceAll(ret, "17", "1z");
			}
			else if (String::equals("14", yearOnly) && (isGcc && m_versionMajorMinor < 500))
			{
				String::replaceAll(ret, "14", "1y");
			}

			ret = "-std=" + ret;
			outArgList.emplace_back(std::move(ret));
		}
	}
	else
	{
		if (RegexPatterns::matchesGnuCStandard(ret))
		{
			std::string yearOnly = ret;
			String::replaceAll(yearOnly, "gnu", "");
			String::replaceAll(yearOnly, "c", "");

			// TODO: determine correct revision where 23 can be used
			if (String::equals("23", yearOnly) && (isGcc && m_versionMajorMinor < 1500))
			{
				String::replaceAll(ret, "23", "2x");
			}

			ret = "-std=" + ret;
			outArgList.emplace_back(std::move(ret));
		}
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addDebuggingInformationOption(StringList& outArgList) const
{
	// TODO: Control debugging information level (g, g0-g3) from configurations
	if (m_state.configuration.debugSymbols())
	{
		outArgList.emplace_back("-g3");
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addProfileInformation(StringList& outArgList) const
{
	if (m_state.configuration.enableProfiling())
	{
		if (!m_project.isSharedLibrary())
		{
			std::string option{ "-pg" };
			// if (isFlagSupported(option))
			outArgList.emplace_back(std::move(option));
		}
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addSanitizerOptions(StringList& outArgList, const BuildState& inState)
{
	StringList sanitizers;
	if (inState.configuration.sanitizeAddress())
	{
		sanitizers.emplace_back("address");
	}
	if (inState.configuration.sanitizeHardwareAddress())
	{
		sanitizers.emplace_back("hwaddress");
	}
	if (inState.configuration.sanitizeThread())
	{
		sanitizers.emplace_back("thread");
	}
	if (inState.configuration.sanitizeLeaks())
	{
		sanitizers.emplace_back("leak");
	}
	if (inState.configuration.sanitizeUndefinedBehavior())
	{
		sanitizers.emplace_back("undefined");
	}

	if (!sanitizers.empty())
	{
		auto list = String::join(sanitizers, ',');
		outArgList.emplace_back(fmt::format("-fsanitize={}", list));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addSanitizerOptions(StringList& outArgList) const
{
	if (m_state.configuration.enableSanitizers())
	{
		CompilerCxxGCC::addSanitizerOptions(outArgList, m_state);
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addCompileOptions(StringList& outArgList) const
{
	for (auto& option : m_project.compileOptions())
	{
		List::addIfDoesNotExist(outArgList, option);
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addCharsets(StringList& outArgList) const
{
	auto inputCharset = String::toUpperCase(m_project.inputCharset());
	outArgList.emplace_back(fmt::format("-finput-charset={}", inputCharset));

	auto execCharset = String::toUpperCase(m_project.executionCharset());
	outArgList.emplace_back(fmt::format("-fexec-charset={}", execCharset));

	// Note: also, -fwide-exec-charset=charset
	//   Setting this to a value higher than wchar_t is not recommended
}

/*****************************************************************************/
void CompilerCxxGCC::addDiagnosticColorOption(StringList& outArgList) const
{
	std::string option{ "-fdiagnostics-color=always" };
	if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
}

/*****************************************************************************/
void CompilerCxxGCC::addLibStdCppCompileOption(StringList& outArgList, const SourceType derivative) const
{
	UNUSED(outArgList, derivative);
}

/*****************************************************************************/
void CompilerCxxGCC::addPositionIndependentCodeOption(StringList& outArgList) const
{
	if (!m_state.environment->isWindowsTarget())
	{
		if (m_project.positionIndependentCode())
		{
			std::string option{ "-fPIC" };
			// if (isFlagSupported(option))
			List::addIfDoesNotExist(outArgList, std::move(option));
		}
		else if (m_project.positionIndependentExecutable())
		{
			std::string option{ "-fPIE" };
			// if (isFlagSupported(option))
			List::addIfDoesNotExist(outArgList, std::move(option));
		}
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addNoRunTimeTypeInformationOption(StringList& outArgList) const
{
	if (!m_project.runtimeTypeInformation())
	{
		std::string option{ "-fno-rtti" };
		// if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addNoExceptionsOption(StringList& outArgList) const
{
	if (!m_project.exceptions())
	{
		std::string option{ "-fno-exceptions" };
		// if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addFastMathOption(StringList& outArgList) const
{
	if (m_project.fastMath())
	{
		std::string option{ "-ffast-math" };
		// if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addThreadModelCompileOption(StringList& outArgList) const
{
	if (m_project.threads() && !m_state.environment->isEmbeddedTarget())
	{
		std::string option{ "-pthread" };
		// if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
	}
}

/*****************************************************************************/
bool CompilerCxxGCC::addArchitecture(StringList& outArgList, const std::string& inArch) const
{
	return CompilerCxxGCC::addArchitectureToCommand(outArgList, inArch, m_state);
}

/*****************************************************************************/
void CompilerCxxGCC::addLinkTimeOptimizations(StringList& outArgList) const
{
	if (m_state.configuration.interproceduralOptimization())
	{
		std::string noFatLto{ "-fno-fat-lto-objects" };
		// if (isFlagSupported(noFatLto))
		List::addIfDoesNotExist(outArgList, std::string(noFatLto));

		std::string lto{ "-flto" };
		// if (isFlagSupported(lto))
		List::addIfDoesNotExist(outArgList, std::string(lto));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addCppCoroutines(StringList& outArgList) const
{
	if (m_project.cppCoroutines() && m_versionMajorMinor >= 1000)
	{
		std::string option{ "-fcoroutines" };
		// if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addCppConcepts(StringList& outArgList) const
{
	if (m_project.cppConcepts() && m_versionMajorMinor >= 600)
	{
		std::string option{ "-fconcepts" };
		// if (isFlagSupported(option))
		List::addIfDoesNotExist(outArgList, std::move(option));
	}
}

/*****************************************************************************/
void CompilerCxxGCC::addObjectiveCxxRuntimeOption(StringList& outArgList, const SourceType derivative) const
{
	/*const bool isObjCxx = derivative == SourceType::ObjectiveCPlusPlus || derivative == SourceType::ObjectiveC;
	if (isObjCxx)
	{
#if defined(CHALET_MACOS)
		std::string objcRuntime{ "-fnext-runtime" };
#else
		std::string objcRuntime{ "-fgnu-runtime" };
#endif
		// if (isFlagSupported(objcRuntime))
		List::addIfDoesNotExist(outArgList, std::move(objcRuntime));
	}*/
	UNUSED(outArgList, derivative);
}

/*****************************************************************************/
bool CompilerCxxGCC::addSystemRootOption(StringList& outArgList) const
{
#if defined(CHALET_MACOS)
	return CompilerCxxAppleClang::addSystemRootOption(outArgList, m_state, this->quotedPaths());
#else
	UNUSED(outArgList);
	return true;
#endif
}

/*****************************************************************************/
bool CompilerCxxGCC::addSystemIncludes(StringList& outArgList) const
{
#if defined(CHALET_LINUX)
	const auto& systemIncludes = m_state.environment->targetSystemPaths();
	const auto& sysroot = m_state.environment->sysroot();
	if (!systemIncludes.empty() && !sysroot.empty())
	{
		outArgList.emplace_back("-nostdinc");

		for (auto& include : systemIncludes)
		{
			outArgList.emplace_back("-isystem");
			outArgList.emplace_back(include);
		}
	}

	return true;
#else
	UNUSED(outArgList);
	return true;
#endif
}

/*****************************************************************************/
bool CompilerCxxGCC::addArchitectureToCommand(StringList& outArgList, const std::string& inArch, const BuildState& inState)
{
	UNUSED(inArch);

	auto hostArch = inState.info.hostArchitecture();
	auto targetArch = inState.info.targetArchitecture();
	auto requestedArch = inState.info.targetArchitectureString();

	if (inState.environment->isMingw() || String::equals(StringList{ "arm", "armhf", "arm64", "aarch64" }, requestedArch))
	{
		// don't do anything yet
		return false;
	}

	if (hostArch == targetArch && targetArch != Arch::Cpu::Unknown)
		return false;

	// https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
	// gcc -Q --help=target

	const auto& arches86 = getSupportedX86Architectures();

	std::string arch;
	std::string tune;
	std::string flags;
	if (String::equals(StringList{ "intel", "generic" }, requestedArch))
	{
		tune = requestedArch;
		flags = "-m64";
	}
	else if (String::equals(StringList{ "x86_64", "x64" }, requestedArch))
	{
		arch = "x86-64";
		tune = "generic";
		flags = "-m64";
	}
	else if (String::equals("x86", requestedArch))
	{
		arch = tune = "i686";
		flags = "-m32";
	}
	else if (String::equals(arches86, requestedArch))
	{
		arch = tune = requestedArch;
		flags = "-m32";
	}
	else
	{
		arch = tune = requestedArch;
		flags = "-m64";
	}

	if (!arch.empty())
	{
		auto archFlag = fmt::format("-march={}", arch);
		// if (isFlagSupported(archFlag))
		outArgList.emplace_back(std::move(archFlag));
	}

	if (!tune.empty())
	{
		auto tuneFlag = fmt::format("-mtune={}", tune);
		// if (isFlagSupported(tuneFlag))
		outArgList.emplace_back(std::move(tuneFlag));
	}

	if (!flags.empty())
	{
		// if (isFlagSupported(flags))
		outArgList.emplace_back(std::move(flags));
	}

	return true;
}

/*****************************************************************************/
const StringList& CompilerCxxGCC::getSupportedX86Architectures()
{
	static StringList kSupportedX86Arches{
		"i386",
		"i486",
		"i586",
		"pentium",
		"lakemont",
		"pentium-mmx",
		"pentiumpro",
		"i686",
		"pentium2",
		"pentium3",
		"pentium3m",
		"pentium-m",
		"pentium4m",
		"prescott",
		"k6",
		"k6-2",
		"k6-3",
		"athlon",
		"athlon-tbird",
		"athlon-4",
		"athlon-xp",
		"athlon-mp",
		"winchip-c6",
		"winchip2",
		"c3",
		"c3-2",
		"c7",
		"samuel-2",
		"nehemiah",
		"esther",
		"geode",
	};

	return kSupportedX86Arches;
}

/*****************************************************************************/
/*const StringList& CompilerCxxGCC::getSupportedX64Architectures()
{
	static StringList kSupportedX64Arches{
		"x86-64",
		"x86-64-v2",
		"x86-64-v3",
		"x86-64-v4",
		"k8",
		"opteron",
		"athlon64",
		"athlon-fx",
		"k8-sse3",
		"opteron-sse3",
		"athlon64-sse3",
		"amdfam10",
		"barcelona",
		"bdver1",
		"bdver2",
		"bdver3",
		"bdver4",
		"znver1",
		"znver2",
		"znver3",
		"btver1",
		"btver2",
		"eden-x2",
		"eden-x4",
		"nano",
		"nano-1000",
		"nano-2000",
		"nano-3000",
		"nano-x2",
		"nano-x4",
	};

	return kSupportedX64Arches;
}*/
}
