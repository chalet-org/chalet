/*
	Distributed under the OSI-approved BSD 3-Clause License.
	See accompanying file LICENSE.txt for details.
*/

#include "Compile/CompilerCxx/CompilerCxxIntelClassicGCC.hpp"

#include "BuildEnvironment/IBuildEnvironment.hpp"
#include "Cache/WorkspaceCache.hpp"
#include "State/BuildPaths.hpp"
#include "State/BuildState.hpp"
#include "State/Target/SourceTarget.hpp"
#include "System/Files.hpp"
#include "Utility/List.hpp"
#include "Utility/String.hpp"

namespace chalet
{
/*****************************************************************************/
CompilerCxxIntelClassicGCC::CompilerCxxIntelClassicGCC(const BuildState& inState, const SourceTarget& inProject) :
	CompilerCxxGCC(inState, inProject)
{
}

/*****************************************************************************/
bool CompilerCxxIntelClassicGCC::initialize()
{
	if (!CompilerCxxGCC::initialize())
		return false;

	if (m_project.usesPrecompiledHeader())
	{
		m_pchSource = m_state.environment->getPrecompiledHeaderSourceFile(m_project);

		if (!Files::pathExists(m_pchSource))
		{
			const auto& pch = m_project.precompiledHeader();
			auto pchMinusLocation = Files::getCanonicalPath(pch);
			if (!Files::createFileWithContents(m_pchSource, fmt::format("// Generated by Chalet\n\n#include \"{}\"", pchMinusLocation)))
				return false;
		}
	}

	return true;
}

/*****************************************************************************/
StringList CompilerCxxIntelClassicGCC::getPrecompiledHeaderCommand(const std::string& inputFile, const std::string& outputFile, const std::string& dependency, const std::string& arch)
{
	StringList ret;
	if (m_project.usesPrecompiledHeader())
	{
		ret = CompilerCxxGCC::getPrecompiledHeaderCommand(inputFile, outputFile, dependency, arch);
		ret.pop_back();
		ret.emplace_back(getQuotedPath(m_pchSource));
	}

	return ret;
}

/*****************************************************************************/
StringList CompilerCxxIntelClassicGCC::getWarningExclusions() const
{
	return {
		"pedantic",
		"cast-align",
		"double-promotion",
		"redundant-decls",
		"noexcept",
		"old-style-cast",
		"strict-null-sentinel",
		"invalid-pch"
	};
}

/*****************************************************************************/
void CompilerCxxIntelClassicGCC::addPchInclude(StringList& outArgList, const SourceType derivative) const
{
	if (precompiledHeaderAllowedForSourceType(derivative))
	{
		outArgList.emplace_back("-include");

		auto pchIntermediate = m_state.environment->getPrecompiledHeaderIntermediateFile(m_project);
		// const auto objDirPch = m_state.paths.getPrecompiledHeaderInclude(m_project);
		outArgList.emplace_back(getPathCommand("", pchIntermediate));
	}
}

/*****************************************************************************/
void CompilerCxxIntelClassicGCC::addCharsets(StringList& outArgList) const
{
	UNUSED(outArgList);
}

/*****************************************************************************/
void CompilerCxxIntelClassicGCC::addFastMathOption(StringList& outArgList) const
{
	if (m_project.fastMath())
	{
		List::addIfDoesNotExist(outArgList, "-fp-model=fast");
	}
}

/*****************************************************************************/
void CompilerCxxIntelClassicGCC::addLinkTimeOptimizations(StringList& outArgList) const
{
	UNUSED(outArgList);
}

}
