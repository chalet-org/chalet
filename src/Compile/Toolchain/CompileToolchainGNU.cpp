/*
	Distributed under the OSI-approved BSD 3-Clause License.
	See accompanying file LICENSE.txt for details.
*/

#include "Compile/Toolchain/CompileToolchainGNU.hpp"

#include "Compile/Environment/ICompileEnvironment.hpp"
#include "State/AncillaryTools.hpp"
#include "State/BuildConfiguration.hpp"
#include "State/BuildInfo.hpp"
#include "State/BuildPaths.hpp"
#include "State/BuildState.hpp"
#include "State/CompilerTools.hpp"
#include "State/Target/SourceTarget.hpp"
#include "Terminal/Commands.hpp"
#include "Utility/List.hpp"
#include "Utility/RegexPatterns.hpp"
#include "Utility/String.hpp"

namespace chalet
{
/*****************************************************************************/
CompileToolchainGNU::CompileToolchainGNU(const BuildState& inState, const SourceTarget& inProject) :
	ICompileToolchain(inState, inProject)
{
}

/*****************************************************************************/
ToolchainType CompileToolchainGNU::type() const noexcept
{
	return ToolchainType::GNU;
}

/*****************************************************************************/
bool CompileToolchainGNU::initialize()
{
	m_arch = m_state.info.targetArchitectureString();

	initializeArchPresets();
	// initializeSupportedLinks();

	if (m_project.usesPch())
	{
		auto makeIntermediateHeader = [this](const std::string outPath, const std::string& pch) -> bool {
			if (!Commands::pathExists(outPath))
			{
				auto pragmaId = this->type() == ToolchainType::LLVM ? "clang" : "GCC";
				auto pchAbsolute = Commands::getAbsolutePath(pch);
				auto contents = fmt::format(R"cpp(// Generated by Chalet

#pragma {pragmaId} system_header
#ifdef __cplusplus
	#include "{pchAbsolute}"
#endif)cpp",
					FMT_ARG(pragmaId),
					FMT_ARG(pchAbsolute));

				if (!Commands::createFileWithContents(outPath, contents))
					return false;
			}

			return true;
		};

		const auto& objDir = m_state.paths.objDir();
		const auto& pch = m_project.pch();
		std::string pchIntermediate = fmt::format("{}/{}", objDir, pch);

#if defined(CHALET_MACOS)
		if (m_state.info.targetArchitecture() == Arch::Cpu::UniversalMacOS)
		{
			auto baseFolder = String::getPathFolder(pchIntermediate);
			auto filename = String::getPathFilename(pchIntermediate);

			for (auto& arch : m_state.info.universalArches())
			{
				auto outFile = fmt::format("{}_{}/{}", baseFolder, arch, filename);

				if (!makeIntermediateHeader(outFile, pch))
					return false;
			}
		}
		else
#endif
		{
			if (!makeIntermediateHeader(pchIntermediate, pch))
				return false;
		}
	}

#if defined(CHALET_WIN32)
	if (!createWindowsApplicationManifest())
		return false;

	if (!createWindowsApplicationIcon())
		return false;
#endif

	return true;
}

/*****************************************************************************/
StringList CompileToolchainGNU::getPchCompileCommand(const std::string& inputFile, const std::string& outputFile, const bool generateDependency, const std::string& dependency, const std::string& arch)
{
	StringList ret;

	UNUSED(arch);

	auto& executable = m_state.toolchain.compilerCxx(m_project.language()).path;

	if (executable.empty())
		return ret;

	addExectuable(ret, executable);

	if (generateDependency)
	{
		ret.emplace_back("-MT");
		ret.push_back(outputFile);
		ret.emplace_back("-MMD");
		ret.emplace_back("-MP");
		ret.emplace_back("-MF");
		ret.push_back(dependency);
	}

	const auto specialization = m_project.language() == CodeLanguage::CPlusPlus ? CxxSpecialization::CPlusPlus : CxxSpecialization::C;
	addOptimizationOption(ret);
	addLanguageStandard(ret, specialization);
	addWarnings(ret);

	addLibStdCppCompileOption(ret, specialization);
	addPositionIndependentCodeOption(ret);
	addCompileOptions(ret);
	addObjectiveCxxRuntimeOption(ret, specialization);
	addDiagnosticColorOption(ret);
	addNoRunTimeTypeInformationOption(ret);
	addNoExceptionsOption(ret);
	addThreadModelCompileOption(ret);
	addArchitecture(ret);
	addArchitectureOptions(ret);
	addMacosMultiArchOption(ret, arch);

	addDebuggingInformationOption(ret);
	addProfileInformationCompileOption(ret);

	addDefines(ret);
	addIncludes(ret);
	addMacosSysRootOption(ret);

	// ret.emplace_back("-x");
	// if (specialization == CxxSpecialization::C)
	// 	ret.emplace_back("c-header");
	// else
	// 	ret.emplace_back("c++-header");

	ret.emplace_back("-o");
	ret.push_back(outputFile);
	ret.emplace_back("-c");
	ret.push_back(inputFile);

	return ret;
}

/*****************************************************************************/
StringList CompileToolchainGNU::getRcCompileCommand(const std::string& inputFile, const std::string& outputFile, const bool generateDependency, const std::string& dependency)
{
	StringList ret;

	if (m_state.toolchain.compilerWindowsResource().empty())
		return ret;

	addExectuable(ret, m_state.toolchain.compilerWindowsResource());

	if (m_state.toolchain.isCompilerWindowsResourceLLVMRC())
	{
		// llvm-rc is basically rc.exe w/ GNU-style args
		addDefines(ret);
		addIncludes(ret);

		ret.emplace_back("-Fo");
		ret.push_back(outputFile);
		ret.push_back(inputFile);
	}
	else
	{
		ret.emplace_back("-J");
		ret.emplace_back("rc");

		ret.emplace_back("-O");
		ret.emplace_back("coff");

		if (generateDependency)
		{
			// Note: The dependency generation args have to be passed into the preprocessor
			//   The underlying preprocessor command is "gcc -E -xc-header -DRC_INVOKED"
			//   This runs in C mode, so we don't want any c++ flags passed in
			//   See: https://sourceware.org/binutils/docs/binutils/windres.html

			ret.emplace_back("--preprocessor-arg=-MT");
			ret.emplace_back(fmt::format("--preprocessor-arg={}", outputFile));
			ret.emplace_back("--preprocessor-arg=-MMD");
			ret.emplace_back("--preprocessor-arg=-MP");
			ret.emplace_back("--preprocessor-arg=-MF");
			ret.emplace_back(fmt::format("--preprocessor-arg={}", dependency));
		}

		addDefines(ret);
		addIncludes(ret);

		ret.emplace_back("-i");
		ret.push_back(inputFile);
		ret.emplace_back("-o");
		ret.push_back(outputFile);
	}

	return ret;
}

/*****************************************************************************/
StringList CompileToolchainGNU::getCxxCompileCommand(const std::string& inputFile, const std::string& outputFile, const bool generateDependency, const std::string& dependency, const CxxSpecialization specialization)
{
	StringList ret;

	auto& executable = m_state.toolchain.compilerCxx(m_project.language()).path;

	if (executable.empty())
		return ret;

	addExectuable(ret, executable);

	if (generateDependency)
	{
		ret.emplace_back("-MT");
		ret.push_back(outputFile);
		ret.emplace_back("-MMD");
		ret.emplace_back("-MP");
		ret.emplace_back("-MF");
		ret.push_back(dependency);
	}

	addOptimizationOption(ret);
	addLanguageStandard(ret, specialization);
	addWarnings(ret);
	addObjectiveCxxCompileOption(ret, specialization);

	addLibStdCppCompileOption(ret, specialization);
	addPositionIndependentCodeOption(ret);
	addCompileOptions(ret);
	addObjectiveCxxRuntimeOption(ret, specialization);
	addDiagnosticColorOption(ret);
	addNoRunTimeTypeInformationOption(ret);
	addNoExceptionsOption(ret);
	addThreadModelCompileOption(ret);
	addArchitecture(ret);
	addArchitectureOptions(ret);
	addMacosMultiArchOption(ret, std::string());

	addDebuggingInformationOption(ret);
	addProfileInformationCompileOption(ret);

	addDefines(ret);

	// Before other includes
	if (specialization == CxxSpecialization::C || specialization == CxxSpecialization::CPlusPlus)
		addPchInclude(ret);

	addIncludes(ret);
	addMacosSysRootOption(ret);

	ret.emplace_back("-o");
	ret.push_back(outputFile);
	ret.emplace_back("-c");
	ret.push_back(inputFile);

	return ret;
}

/*****************************************************************************/
// TODO: This treats clang as a dylib target which is wrong... (only on apple)
StringList CompileToolchainGNU::getLinkerTargetCommand(const std::string& outputFile, const StringList& sourceObjs, const std::string& outputFileBase)
{
	switch (m_project.kind())
	{
		case ProjectKind::SharedLibrary: {
			return getDynamicLibTargetCommand(outputFile, sourceObjs, outputFileBase);
		}

		case ProjectKind::StaticLibrary: {
			return getStaticLibTargetCommand(outputFile, sourceObjs);
		}

		case ProjectKind::Executable: {
			return getExecutableTargetCommand(outputFile, sourceObjs);
		}

		default:
			break;
	}

	return {};
}

/*****************************************************************************/
StringList CompileToolchainGNU::getDynamicLibTargetCommand(const std::string& outputFile, const StringList& sourceObjs, const std::string& outputFileBase) const
{
	StringList ret;

	auto& executable = m_state.toolchain.compilerCxx(m_project.language()).path;

	if (executable.empty())
		return ret;

	addExectuable(ret, executable);

	ret.emplace_back("-shared");
	if (m_state.environment->isMingw())
	{
		std::string mingwLinkerOptions;
		if (m_project.windowsOutputDef())
		{
			mingwLinkerOptions = fmt::format("-Wl,--output-def={}.def", outputFileBase);
		}
		mingwLinkerOptions += fmt::format("-Wl,--out-implib={}.a", outputFileBase);
		ret.emplace_back(std::move(mingwLinkerOptions));

		ret.emplace_back("-Wl,--dll");
	}
	else
	{
		addPositionIndependentCodeOption(ret);
	}

	addStripSymbolsOption(ret);
	addLinkerOptions(ret);
	addMacosSysRootOption(ret);
	addProfileInformationLinkerOption(ret);
	addLinkTimeOptimizationOption(ret);
	addThreadModelLinkerOption(ret);
	addArchitecture(ret);
	addArchitectureOptions(ret);
	addLinkerScripts(ret);
	addLibStdCppLinkerOption(ret);
	addStaticCompilerLibraryOptions(ret);
	addSubSystem(ret);
	addEntryPoint(ret);
	addMacosFrameworkOptions(ret);

	addLibDirs(ret);

	ret.emplace_back("-o");
	ret.push_back(outputFile);
	addSourceObjects(ret, sourceObjs);

	addLinks(ret);
	addObjectiveCxxLink(ret);

	return ret;
}

/*****************************************************************************/
StringList CompileToolchainGNU::getStaticLibTargetCommand(const std::string& outputFile, const StringList& sourceObjs) const
{
	StringList ret;

	if (m_state.toolchain.archiver().empty())
		return ret;

	addExectuable(ret, m_state.toolchain.archiver());

	if (m_state.toolchain.isArchiverLibTool())
	{
		ret.emplace_back("-static");
		ret.emplace_back("-no_warning_for_no_symbols");
		ret.emplace_back("-o");
	}
	else
	{
		ret.emplace_back("-c");
		ret.emplace_back("-r");
		ret.emplace_back("-s");
	}

	ret.push_back(outputFile);
	addSourceObjects(ret, sourceObjs);

	return ret;
}

/*****************************************************************************/
StringList CompileToolchainGNU::getExecutableTargetCommand(const std::string& outputFile, const StringList& sourceObjs) const
{
	StringList ret;

	auto& executable = m_state.toolchain.compilerCxx(m_project.language()).path;

	if (executable.empty())
		return ret;

	addExectuable(ret, executable);

	addLibDirs(ret);

	ret.emplace_back("-o");
	ret.push_back(outputFile);

	addRunPath(ret);
	addSourceObjects(ret, sourceObjs);

	addLinks(ret);

	addStripSymbolsOption(ret);
	addLinkerOptions(ret);
	addMacosSysRootOption(ret);
	addProfileInformationLinkerOption(ret);
	addLinkTimeOptimizationOption(ret);
	addThreadModelLinkerOption(ret);
	addArchitecture(ret);
	addArchitectureOptions(ret);
	addMacosMultiArchOption(ret, std::string());

	addLinkerScripts(ret);
	addLibStdCppLinkerOption(ret);
	addStaticCompilerLibraryOptions(ret);
	addSubSystem(ret);
	addEntryPoint(ret);
	addMacosFrameworkOptions(ret);

	return ret;
}

/*****************************************************************************/
StringList CompileToolchainGNU::getLinkExclusions() const
{
	return {};
}

/*****************************************************************************/
StringList CompileToolchainGNU::getWarningExclusions() const
{
	return {};
}

/*****************************************************************************/
bool CompileToolchainGNU::isFlagSupported(const std::string& inFlag) const
{
	if (String::contains('=', inFlag))
	{
		auto cutoff = inFlag.find('=');
		// std::string flag = inFlag.substr(cutoff + 1);
		std::string flag = inFlag.substr(0, cutoff);
		return m_state.environment->isCompilerFlagSupported(String::toLowerCase(flag));
	}
	else
	{
		return m_state.environment->isCompilerFlagSupported(String::toLowerCase(inFlag));
	}
}

/*****************************************************************************/
bool CompileToolchainGNU::isLinkSupported(const std::string& inLink) const
{
	if (m_supportedLinksInitialized && m_state.environment->isGcc())
	{
		return m_supportedLinks.find(inLink) != m_supportedLinks.end();
	}

	return true;
}

/*****************************************************************************/
void CompileToolchainGNU::addSourceObjects(StringList& outArgList, const StringList& sourceObjs) const
{
	for (auto& source : sourceObjs)
	{
		outArgList.push_back(source);
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addIncludes(StringList& outArgList) const
{
	const std::string prefix{ "-I" };
	for (const auto& dir : m_project.includeDirs())
	{
		std::string outDir = dir;
		if (String::endsWith('/', outDir))
			outDir.pop_back();

		outArgList.emplace_back(getPathCommand(prefix, outDir));
	}
	for (const auto& dir : m_project.locations())
	{
		std::string outDir = dir;
		if (String::endsWith('/', outDir))
			outDir.pop_back();

		outArgList.emplace_back(getPathCommand(prefix, outDir));
	}

	if (m_project.usesPch())
	{
		auto outDir = String::getPathFolder(m_project.pch());
		List::addIfDoesNotExist(outArgList, getPathCommand(prefix, outDir));
	}

#if defined(CHALET_MACOS) || defined(CHALET_LINUX)
	// must be last
	List::addIfDoesNotExist(outArgList, getPathCommand(prefix, "/usr/local/include/"));
#endif
}

/*****************************************************************************/
void CompileToolchainGNU::addLibDirs(StringList& outArgList) const
{
	const std::string prefix{ "-L" };
	for (const auto& dir : m_project.libDirs())
	{
		outArgList.emplace_back(getPathCommand(prefix, dir));
	}

	outArgList.emplace_back(getPathCommand(prefix, m_state.paths.buildOutputDir()));

#if defined(CHALET_MACOS) || defined(CHALET_LINUX)
	// must be last
	List::addIfDoesNotExist(outArgList, getPathCommand(prefix, "/usr/local/lib/"));
#endif
}

/*****************************************************************************/
void CompileToolchainGNU::addWarnings(StringList& outArgList) const
{
	auto excludes = getWarningExclusions();

	const std::string prefix{ "-W" };
	for (auto& warning : m_project.warnings())
	{
		if (List::contains(excludes, warning))
			continue;

		std::string out;
		if (String::equals(warning, "pedantic-errors"))
		{
			out = "-" + warning;
		}
		else
		{
			out = prefix + warning;
		}

		// if (isFlagSupported(out))
		outArgList.emplace_back(std::move(out));
	}

	if (m_project.usesPch())
	{
		std::string warning = "invalid-pch";

		if (!List::contains(excludes, warning))
		{
			std::string invalidPch = prefix + warning;
			// if (isFlagSupported(invalidPch))
			List::addIfDoesNotExist(outArgList, std::move(invalidPch));
		}
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addDefines(StringList& outArgList) const
{
	const std::string prefix{ "-D" };
	for (auto& define : m_project.defines())
	{
		outArgList.emplace_back(prefix + define);
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addLinks(StringList& outArgList) const
{
	const std::string prefix{ "-l" };
	const bool hasStaticLinks = m_project.staticLinks().size() > 0;
	const bool hasDynamicLinks = m_project.links().size() > 0;

	if (hasStaticLinks)
	{
		startStaticLinkGroup(outArgList);

		for (auto& staticLink : m_project.staticLinks())
		{
			if (isLinkSupported(staticLink))
				outArgList.emplace_back(prefix + staticLink);
		}

		endStaticLinkGroup(outArgList);
		startExplicitDynamicLinkGroup(outArgList);
	}

	if (hasDynamicLinks)
	{
		auto excludes = getLinkExclusions();

		for (auto& link : m_project.links())
		{
			if (List::contains(excludes, link))
				continue;

			if (isLinkSupported(link))
				outArgList.emplace_back(prefix + link);
		}
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addPchInclude(StringList& outArgList) const
{
	// TODO: Potential for more than one pch?
	if (m_project.usesPch())
	{
		const auto objDirPch = m_state.paths.getPrecompiledHeaderInclude(m_project);

		outArgList.emplace_back("-include");
		outArgList.emplace_back(getPathCommand("", objDirPch));
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addOptimizationOption(StringList& outArgList) const
{
	std::string opt;

	OptimizationLevel level = m_state.configuration.optimizationLevel();

	if (m_state.configuration.debugSymbols()
		&& level != OptimizationLevel::Debug
		&& level != OptimizationLevel::None
		&& level != OptimizationLevel::CompilerDefault)
	{
		// force -O0 (anything else would be in error)
		opt = "-O0";
	}
	else
	{
		switch (level)
		{
			case OptimizationLevel::L1:
				opt = "-O1";
				break;

			case OptimizationLevel::L2:
				opt = "-O2";
				break;

			case OptimizationLevel::L3:
				opt = "-O3";
				break;

			case OptimizationLevel::Debug:
				opt = "-Og";
				break;

			case OptimizationLevel::Size:
				opt = "-Os";
				break;

			case OptimizationLevel::Fast:
				opt = "-Ofast";
				break;

			case OptimizationLevel::None:
				opt = "-O0";
				break;

			case OptimizationLevel::CompilerDefault:
			default:
				break;
		}
	}

	if (opt.empty())
		return;

	outArgList.emplace_back(std::move(opt));
}

/*****************************************************************************/
void CompileToolchainGNU::addRunPath(StringList& outArgList) const
{
#if defined(CHALET_LINUX)
	outArgList.emplace_back("-Wl,-rpath,'$$ORIGIN'"); // Note: Single quotes are required!
#else
	UNUSED(outArgList);
#endif
}

/*****************************************************************************/
void CompileToolchainGNU::addLanguageStandard(StringList& outArgList, const CxxSpecialization specialization) const
{
	const bool useC = m_project.language() == CodeLanguage::C || specialization == CxxSpecialization::ObjectiveC;
	const auto& langStandard = useC ? m_project.cStandard() : m_project.cppStandard();
	std::string ret = String::toLowerCase(langStandard);

	// TODO: Make this "dumber" so it only the allowed strings used by each compiler

	if (!useC)
	{
		if (RegexPatterns::matchesGnuCppStandard(ret))
		{
			ret = "-std=" + ret;
			outArgList.emplace_back(std::move(ret));
		}
	}
	else
	{
		if (RegexPatterns::matchesGnuCStandard(ret))
		{
			ret = "-std=" + ret;
			outArgList.emplace_back(std::move(ret));
		}
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addDebuggingInformationOption(StringList& outArgList) const
{
	// TODO: Control debugging information level (g, g0-g3) from configurations
	if (m_state.configuration.debugSymbols())
	{
		outArgList.emplace_back("-g3");
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addProfileInformationCompileOption(StringList& outArgList) const
{
	// TODO: gcc/clang distinction on mac?

	if (m_state.configuration.enableProfiling())
	{
		if (!m_project.isSharedLibrary())
		{
			std::string profileInfo{ "-pg" };
			// if (isFlagSupported(profileInfo))
			outArgList.emplace_back(std::move(profileInfo));
		}
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addCompileOptions(StringList& outArgList) const
{
	for (auto& option : m_project.compileOptions())
	{
		List::addIfDoesNotExist(outArgList, option);
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addDiagnosticColorOption(StringList& outArgList) const
{
	std::string diagnosticColor{ "-fdiagnostics-color=always" };
	if (isFlagSupported(diagnosticColor))
		List::addIfDoesNotExist(outArgList, std::move(diagnosticColor));
}

/*****************************************************************************/
void CompileToolchainGNU::addLibStdCppCompileOption(StringList& outArgList, const CxxSpecialization specialization) const
{
	UNUSED(outArgList, specialization);
}

/*****************************************************************************/
void CompileToolchainGNU::addPositionIndependentCodeOption(StringList& outArgList) const
{
	if (!m_state.environment->isMingw())
	{
		std::string fpic{ "-fPIC" };
		// if (isFlagSupported(fpic))
		List::addIfDoesNotExist(outArgList, std::move(fpic));
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addNoRunTimeTypeInformationOption(StringList& outArgList) const
{
	if (!m_project.rtti())
	{
		std::string noRtti{ "-fno-rtti" };
		// if (isFlagSupported(noRtti))
		List::addIfDoesNotExist(outArgList, std::move(noRtti));
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addNoExceptionsOption(StringList& outArgList) const
{
	if (!m_project.exceptions())
	{
		std::string noExceptions{ "-fno-exceptions" };
		// if (isFlagSupported(noExceptions))
		List::addIfDoesNotExist(outArgList, std::move(noExceptions));
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addThreadModelCompileOption(StringList& outArgList) const
{
	auto threadType = m_project.threadType();
	if (!m_state.environment->isWindowsClang() && (threadType == ThreadType::Posix || threadType == ThreadType::Auto))
	{
		std::string pthread{ "-pthread" };
		// if (isFlagSupported(pthread))
		List::addIfDoesNotExist(outArgList, std::move(pthread));
	}
}

/*****************************************************************************/
bool CompileToolchainGNU::addArchitecture(StringList& outArgList) const
{
	auto hostArch = m_state.info.hostArchitecture();
	auto targetArch = m_state.info.targetArchitecture();

	if (m_state.environment->isMingw() && String::equals({ "arm", "arm64" }, m_arch))
	{
		// don't do anything yet
		return false;
	}

	if (hostArch == targetArch && targetArch != Arch::Cpu::Unknown)
		return false;

	// https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
	// gcc -Q --help=target

	std::string arch;
	std::string tune;
	std::string flags;
	if (String::equals({ "intel", "generic" }, m_arch))
	{
		tune = m_arch;
		flags = "-m64";
	}
	else if (String::equals({ "x86_64", "x64" }, m_arch))
	{
		arch = "x86-64";
		tune = "generic";
		flags = "-m64";
	}
	else if (String::equals("x86", m_arch))
	{
		arch = tune = "i686";
		flags = "-m32";
	}
	else if (String::equals(m_arch86, m_arch))
	{
		arch = tune = m_arch;
		flags = "-m32";
	}
	else
	{
		arch = tune = m_arch;
		flags = "-m64";
	}

	if (!arch.empty())
	{
		auto archFlag = fmt::format("-march={}", arch);
		// if (isFlagSupported(archFlag))
		outArgList.emplace_back(std::move(archFlag));
	}

	if (!tune.empty())
	{
		auto tuneFlag = fmt::format("-mtune={}", tune);
		// if (isFlagSupported(tuneFlag))
		outArgList.emplace_back(std::move(tuneFlag));
	}

	if (!flags.empty())
	{
		// if (isFlagSupported(flags))
		outArgList.emplace_back(std::move(flags));
	}

	return true;
}

/*****************************************************************************/
void CompileToolchainGNU::addStripSymbolsOption(StringList& outArgList) const
{
#if defined(CHALET_WIN32) || defined(CHALET_LINUX)
	if (m_state.configuration.stripSymbols())
	{
		std::string strip{ "-s" };
		// if (isFlagSupported(strip))
		outArgList.emplace_back(std::move(strip));
	}
#else
	UNUSED(outArgList);
#endif
}

/*****************************************************************************/
void CompileToolchainGNU::addLinkerOptions(StringList& outArgList) const
{
	for (auto& option : m_project.linkerOptions())
	{
		// if (isFlagSupported(option))
		outArgList.push_back(option);
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addProfileInformationLinkerOption(StringList& outArgList) const
{
	const bool enableProfiling = m_state.configuration.enableProfiling();
	if (enableProfiling && m_project.isExecutable())
	{
		outArgList.emplace_back("-Wl,--allow-multiple-definition");

		std::string profileInfo{ "-pg" };
		// if (isFlagSupported(profileInfo))
		outArgList.emplace_back(std::move(profileInfo));
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addLinkTimeOptimizationOption(StringList& outArgList) const
{
	if (m_state.configuration.linkTimeOptimization())
	{
		std::string lto{ "-flto" };
		// if (isFlagSupported(lto))
		List::addIfDoesNotExist(outArgList, std::move(lto));
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addThreadModelLinkerOption(StringList& outArgList) const
{
	auto threadType = m_project.threadType();
	if (!m_state.environment->isWindowsClang() && (threadType == ThreadType::Posix || threadType == ThreadType::Auto))
	{
		if (m_state.environment->isMingw() && m_project.staticLinking())
		{
			outArgList.emplace_back("-Wl,-Bstatic,--whole-archive");
			outArgList.emplace_back("-lwinpthread");
			outArgList.emplace_back("-Wl,--no-whole-archive");
		}
		else
		{
			List::addIfDoesNotExist(outArgList, "-pthread");
		}
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addLinkerScripts(StringList& outArgList) const
{
	const auto& linkerScript = m_project.linkerScript();
	if (!linkerScript.empty())
	{
		outArgList.emplace_back("-T");
		outArgList.push_back(linkerScript);
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addLibStdCppLinkerOption(StringList& outArgList) const
{
	// Not used in GCC
	UNUSED(outArgList);
}

/*****************************************************************************/
void CompileToolchainGNU::addStaticCompilerLibraryOptions(StringList& outArgList) const
{
	// List::addIfDoesNotExist(outArgList, "-libstdc++");

	if (m_project.staticLinking())
	{
		auto addFlag = [&](std::string flag) {
			// if (isFlagSupported(flag))
			List::addIfDoesNotExist(outArgList, std::move(flag));
		};

		addFlag("-static-libgcc");
		addFlag("-static-libasan");
		addFlag("-static-libtsan");
		addFlag("-static-liblsan");
		addFlag("-static-libubsan");
		addFlag("-static-libstdc++");
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addSubSystem(StringList& outArgList) const
{
	if (m_state.environment->isMingwGcc())
	{
		// MinGW rolls these together for some reason
		// -mwindows and -mconsole kind of do some magic behind the scenes, so it's hard to assume anything

		const ProjectKind kind = m_project.kind();
		const WindowsSubSystem subSystem = m_project.windowsSubSystem();
		const WindowsEntryPoint entryPoint = m_project.windowsEntryPoint();

		if (kind == ProjectKind::Executable)
		{
			if (entryPoint == WindowsEntryPoint::WinMainUnicode || entryPoint == WindowsEntryPoint::MainUnicode)
			{
				List::addIfDoesNotExist(outArgList, "-municode");
			}

			if (subSystem == WindowsSubSystem::Windows)
			{
				List::addIfDoesNotExist(outArgList, "-mwindows");
			}
			else
			{
				List::addIfDoesNotExist(outArgList, "-mconsole");
			}
		}
		else if (kind == ProjectKind::SharedLibrary)
		{
			if (entryPoint == WindowsEntryPoint::DllMain)
			{
				List::addIfDoesNotExist(outArgList, "-mdll");
			}
		}
	}
}

/*****************************************************************************/
void CompileToolchainGNU::addEntryPoint(StringList& outArgList) const
{
	UNUSED(outArgList);

	// MinGW: See addSubSystem
}

/*****************************************************************************/
// Linking (Misc)
/*****************************************************************************/
/*****************************************************************************/
void CompileToolchainGNU::startStaticLinkGroup(StringList& outArgList) const
{
	outArgList.emplace_back("-Wl,--copy-dt-needed-entries");
	outArgList.emplace_back("-Wl,-Bstatic");
	outArgList.emplace_back("-Wl,--start-group");
}

void CompileToolchainGNU::endStaticLinkGroup(StringList& outArgList) const
{
	outArgList.emplace_back("-Wl,--end-group");
}

/*****************************************************************************/
void CompileToolchainGNU::startExplicitDynamicLinkGroup(StringList& outArgList) const
{
	outArgList.emplace_back("-Wl,-Bdynamic");
}

/*****************************************************************************/
void CompileToolchainGNU::addCompilerSearchPaths(StringList& outArgList) const
{
	// Same as addLinks, but with -B, so far, just used in specific gcc calls
	const std::string prefix{ "-B" };
	for (const auto& dir : m_project.libDirs())
	{
		outArgList.emplace_back(getPathCommand(prefix, dir));
	}

	outArgList.emplace_back(getPathCommand(prefix, m_state.paths.buildOutputDir()));

#if defined(CHALET_MACOS) || defined(CHALET_LINUX)
	// must be last
	List::addIfDoesNotExist(outArgList, getPathCommand(prefix, "/usr/local/lib/"));
#endif
}

/*****************************************************************************/
// Objective-C / Objective-C++
/*****************************************************************************/
/*****************************************************************************/
void CompileToolchainGNU::addObjectiveCxxLink(StringList& outArgList) const
{
	UNUSED(outArgList);

	// Removed for now - seems the most concise way to use Objective-C on Linux/MinGW is via gnustep
	//   gcc `gnustep-config --objc-flags` -L/usr/GNUstep/Local/Library/Libraries -lgnustep-base foo.m -o foo

	/*if (m_project.objectiveCxx())
	{
		const std::string prefix{ "-l" };
		std::string objc = prefix + "objc";
		List::addIfDoesNotExist(outArgList, std::move(objc));
	}*/
}

/*****************************************************************************/
void CompileToolchainGNU::addObjectiveCxxCompileOption(StringList& outArgList, const CxxSpecialization specialization) const
{
	// Used by AppleClang
	UNUSED(outArgList, specialization);
}

/*****************************************************************************/
void CompileToolchainGNU::addObjectiveCxxRuntimeOption(StringList& outArgList, const CxxSpecialization specialization) const
{
	const bool isObjCxx = specialization == CxxSpecialization::ObjectiveCPlusPlus || specialization == CxxSpecialization::ObjectiveC;
	if (isObjCxx)
	{
#if defined(CHALET_MACOS)
		std::string objcRuntime{ "-fnext-runtime" };
#else
		std::string objcRuntime{ "-fgnu-runtime" };
#endif
		// if (isFlagSupported(objcRuntime))
		List::addIfDoesNotExist(outArgList, std::move(objcRuntime));
	}
}

/*****************************************************************************/
// MacOS
/*****************************************************************************/
/*****************************************************************************/
void CompileToolchainGNU::addMacosMultiArchOption(StringList& outArgList, const std::string& arch) const
{
	UNUSED(outArgList, arch);
}

/*****************************************************************************/
void CompileToolchainGNU::addMacosSysRootOption(StringList& outArgList) const
{
#if defined(CHALET_MACOS)
	// TODO: Test Homebrew LLVM/GCC with this
	outArgList.emplace_back("-isysroot");
	outArgList.push_back(m_state.tools.applePlatformSdk("macosx"));
#else
	UNUSED(outArgList);
#endif
}

/*****************************************************************************/
void CompileToolchainGNU::addMacosFrameworkOptions(StringList& outArgList) const
{
#if defined(CHALET_MACOS)
	// TODO: Test Homebrew LLVM/GCC with this
	{
		const std::string prefix = "-F";
		for (auto& path : m_project.libDirs())
		{
			outArgList.emplace_back(prefix + path);
		}
		for (auto& path : m_project.macosFrameworkPaths())
		{
			outArgList.emplace_back(prefix + path);
		}
		List::addIfDoesNotExist(outArgList, prefix + "/Library/Frameworks");
	}
	{
		// const std::string suffix = ".framework";
		for (auto& framework : m_project.macosFrameworks())
		{
			outArgList.emplace_back("-framework");
			outArgList.push_back(framework);
			// outArgList.emplace_back(framework + suffix);
		}
	}
#else
	UNUSED(outArgList);
#endif
}

/*****************************************************************************/
void CompileToolchainGNU::initializeArchPresets()
{
	// https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
	if (m_arch86.empty())
	{
		m_arch86 = {
			"i386",
			"i486",
			"i586",
			"pentium",
			"lakemont",
			"pentium-mmx",
			"pentiumpro",
			"i686",
			"pentium2",
			"pentium3",
			"pentium3m",
			"pentium-m",
			"pentium4m",
			"prescott",
			"k6",
			"k6-2",
			"k6-3",
			"athlon",
			"athlon-tbird",
			"athlon-4",
			"athlon-xp",
			"athlon-mp",
			"winchip-c6",
			"winchip2",
			"c3",
			"c3-2",
			"c7",
			"samuel-2",
			"nehemiah",
			"esther",
			"geode",
		};
	}
	/*if (m_arch86_64.empty())
	{
		m_arch86_64 = {
			"x86-64",
			"x86-64-v2",
			"x86-64-v3",
			"x86-64-v4",
			"k8",
			"opteron",
			"athlon64",
			"athlon-fx",
			"k8-sse3",
			"opteron-sse3",
			"athlon64-sse3",
			"amdfam10",
			"barcelona",
			"bdver1",
			"bdver2",
			"bdver3",
			"bdver4",
			"znver1",
			"znver2",
			"znver3",
			"btver1",
			"btver2",
			"eden-x2",
			"eden-x4",
			"nano",
			"nano-1000",
			"nano-2000",
			"nano-3000",
			"nano-x2",
			"nano-x4",
		};
	}*/
}

/*****************************************************************************/
void CompileToolchainGNU::initializeSupportedLinks()
{
	bool oldQuotePaths = m_quotePaths;
	m_quotePaths = false;

	auto isLinkSupportedByExecutable = [](const std::string& inExecutable, const std::string& inLink, const StringList& inDirectories) -> bool {
		// This will print the input if the link is not found in path
		auto file = fmt::format("lib{}.a", inLink);
		StringList cmd{ inExecutable };
		for (auto& dir : inDirectories)
		{
			cmd.push_back(dir);
		}
		cmd.emplace_back(fmt::format("-print-file-name={}", file));

		auto raw = Commands::subprocessOutput(cmd);
		// auto split = String::split(raw, '\n');

		return !String::equals(file, raw);
	};

	// TODO: Links coming from CMake projects

	StringList cmakeProjects;
	StringList projectLinks;
	for (auto& target : m_state.targets)
	{
		if (target->isProject())
		{
			auto& project = static_cast<const SourceTarget&>(*target);
			if (project.isExecutable())
				continue;

			auto file = project.name();
			if (project.isStaticLibrary())
			{
				file += "-s";
			}
			projectLinks.emplace_back(std::move(file));
		}
		else if (target->isCMake())
		{
			// Try to guess based on the project name
			cmakeProjects.push_back(target->name());
		}
	}

	StringList libDirs;
	addCompilerSearchPaths(libDirs); // do not quote paths for this

	auto excludes = getLinkExclusions();

	const auto& exec = m_state.toolchain.compilerCxx(m_project.language()).path;

	for (auto& staticLink : m_project.staticLinks())
	{
		if (isLinkSupportedByExecutable(exec, staticLink, libDirs) || List::contains(projectLinks, staticLink) || String::contains(cmakeProjects, staticLink))
			m_supportedLinks.emplace(staticLink, true);
	}

	for (auto& link : m_project.links())
	{
		if (List::contains(excludes, link))
			continue;

		if (isLinkSupportedByExecutable(exec, link, libDirs) || List::contains(projectLinks, link) || String::contains(cmakeProjects, link))
			m_supportedLinks.emplace(link, true);
	}

	m_quotePaths = oldQuotePaths;

	m_supportedLinksInitialized = true;
}
}
